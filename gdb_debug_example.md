### gdb调试coredump文件

应用环境： 芯片armv7指令集cortex-a9，使用boost库应用出现coredump.

#### GDB调试coredump

```bash
/var/log # gdb -c core-dump-186-Hello-1514808844 /usr/bin/navi/bin/sens
GNU gdb (Linaro GDB) 7.5-2012.12-1
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "armv7l-unknown-linux-gnueabi".
For bug reporting instructions, please see:
<http://bugs.launchpad.net/gdb-linaro/>...
Reading symbols from /usr/bin/navi/bin/sens...done.

warning: exec file is newer than core file.
[New LWP 201]
[New LWP 328]
[New LWP 327]
[New LWP 445]
[New LWP 628]
[New LWP 199]
[New LWP 186]
[New LWP 446]
[New LWP 627]
[New LWP 200]
[New LWP 202]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/tls/v7l/neon/vfp/libthread_db.so.1".
Core was generated by `/usr/bin/navi/bin/sens --config=/usr/bin/navi/etc/sens.ini              '.
Program terminated with signal 11, Segmentation fault.
#0  0x0001a428 in release (this=0x75b00ec0) at /opt/external/boost/boost/smart_ptr/detail/sp_counted_base_spin.hpp:103
103	/opt/external/boost/boost/smart_ptr/detail/sp_counted_base_spin.hpp: No such file or directory.
(gdb) info threads
  Id   Target Id         Frame 
  11   Thread 0x750ff440 (LWP 202) 0x76ce8660 in nanosleep () from /lib/tls/v7l/neon/vfp/libc.so.6
  10   Thread 0x7644d440 (LWP 200) 0x76f11808 in pthread_cond_wait@@GLIBC_2.4 () from /lib/tls/v7l/neon/vfp/libpthread.so.0
  9    Thread 0x724ff440 (LWP 627) 0x76d1bba4 in epoll_wait () from /lib/tls/v7l/neon/vfp/libc.so.6
  8    Thread 0x72cff440 (LWP 446) 0x76ce8660 in nanosleep () from /lib/tls/v7l/neon/vfp/libc.so.6
  7    Thread 0x76f47390 (LWP 186) 0x76f13b40 in do_futex_wait () from /lib/tls/v7l/neon/vfp/libpthread.so.0
  6    Thread 0x76c4d440 (LWP 199) 0x76f11808 in pthread_cond_wait@@GLIBC_2.4 () from /lib/tls/v7l/neon/vfp/libpthread.so.0
  5    Thread 0x71cff440 (LWP 628) 0x76ce8660 in nanosleep () from /lib/tls/v7l/neon/vfp/libc.so.6
  4    Thread 0x734ff440 (LWP 445) 0x76d1bba4 in epoll_wait () from /lib/tls/v7l/neon/vfp/libc.so.6
  3    Thread 0x746ff440 (LWP 327) 0x76d1bba4 in epoll_wait () from /lib/tls/v7l/neon/vfp/libc.so.6
  2    Thread 0x73eff440 (LWP 328) 0x76ce8660 in nanosleep () from /lib/tls/v7l/neon/vfp/libc.so.6
* 1    Thread 0x758ff440 (LWP 201) 0x0001a428 in release (this=0x75b00ec0)
    at /opt/external/boost/boost/smart_ptr/detail/sp_counted_base_spin.hpp:103
```

上面可以看出发生Core Dump的线程ID为1
线程ID为1的栈信息：

```shell
(gdb) bt
#0  0x0001a428 in release (this=0x75b00ec0) at /opt/external/boost/boost/smart_ptr/detail/sp_counted_base_spin.hpp:103
#1  boost::detail::shared_count::~shared_count (this=0x758feca8, __in_chrg=<optimized out>)
    at /opt/external/boost/boost/smart_ptr/detail/shared_count.hpp:473
#2  0x0001a490 in boost::shared_ptr<Deploy>::~shared_ptr (this=0x758feca4, __in_chrg=<optimized out>)
    at /opt/external/boost/boost/smart_ptr/shared_ptr.hpp:336
#3  0x00047930 in OperationInvocation<boost::shared_ptr<Common>, boost::_bi::bind_t<void, boost::_mfi::mf0<void, Common>, boost::_bi::list1<boost::_bi::value<Common*> > > >::~OperationInvocation (this=0x758feca4, 
    __in_chrg=<optimized out>) at /opt/include/ScheduleMethod.hpp:26
#4  0x000be6d8 in ~storage2 (this=0x758feca0, __in_chrg=<optimized out>) at /opt/external/boost/boost/bind/storage.hpp:76
#5  boost::_bi::storage3<boost::_bi::value<SocketServerAdapter*>, boost::_bi::value<boost::shared_ptr<SocketServerAdapter::TcpConnection> >, boost::_bi::value<boost::shared_ptr<std::vector<unsigned char, std::allocator<unsigned char> > > > >::~storage3 (
    this=this@entry=0x758feca0, __in_chrg=<optimized out>) at /opt/external/boost/boost/bind/storage.hpp:125
#6  0x000be6f0 in ~list3 (this=0x758feca0, __in_chrg=<optimized out>) at /opt/external/boost/boost/bind/bind.hpp:358
#7  boost::_bi::bind_t<void, boost::_mfi::mf2<void, SocketServerAdapter, boost::shared_ptr<SocketServerAdapter::TcpConnection>, boost::shared_ptr<std::vector<unsigned char, std::allocator<unsigned char> > > >, boost::_bi::list3<boost::_bi::value<SocketServerAdapter*>, boost::_bi::value<boost::shared_ptr<SocketServerAdapter::TcpConnection> >, boost::_bi::value<boost::shared_ptr<std::vector<unsigned char, std::allocator<unsigned char> > > > > >::~bind_t (this=0x758fec98, __in_chrg=<optimized out>)
    at /opt/external/boost/boost/bind/bind.hpp:1275
#8  0x000bec28 in boost::asio::detail::write_op<boost::asio::basic_stream_socket<boost::asio::ip::tcp, boost::asio::stream_socket_service<boost::asio::ip::tcp> >, boost::asio::mutable_buffers_1, boost::asio::detail::transfer_all_t, boost::_bi::bind_t<void, boost::_mfi::mf2<void, SocketServerAdapter, boost::shared_ptr<SocketServerAdapter::TcpConnection>, boost::shared_ptr<std::vector<unsigned char, std::allocator<unsigned char> > > >, boost::_bi::list3<boost::_bi::value<SocketServerAdapter*>, boost::_bi::value<boost::shared_ptr<SocketServerAdapter::TcpConnection> >, boost::_bi::value<boost::shared_ptr<std::vector<unsigned char, std::allocator<unsigned char> > > > > > >::~write_op (this=0x758fec84, __in_chrg=<optimized out>) at /opt/external/boost/boost/asio/impl/write.hpp:207
#9  0x000c0330 in ~binder2 (this=0x758fec84, __in_chrg=<optimized out>) at /opt/external/boost/boost/asio/detail/bind_handler.hpp:108
#10 boost::asio::detail::reactive_socket_send_op<boost::asio::mutable_buffers_1, boost::asio::detail::write_op<boost::asio::basic_stream_socket<boost::asio::ip::tcp, boost::asio::stream_socket_service<boost::asio::ip::tcp> >, boost::asio::mutable_buffers_1, boost::asio::detail::transfer_all_t, boost::_bi::bind_t<void, boost::_mfi::mf2<void, SocketServerAdapter, boost::shared_ptr<SocketServerAdapter::TcpConnection>, boost::shared_ptr<std::vector<unsigned char, std::allocator<unsigned char> > > >, boost::_bi::list3<boost::_bi::value<SocketServerAdapter*>, boost::_bi::value<boost::shared_ptr<SocketServerAdapter::TcpConnection> >, boost::_bi::value<boost::shared_ptr<std::vector<unsigned char, std::allocator<unsigned char> > > > > > > >::do_complete (owner=0x75b01248, base=<optimized out>)
    at /opt/external/boost/boost/asio/detail/reactive_socket_send_op.hpp:108
#11 0x000b9814 in complete (bytes_transferred=0, ec=..., owner=..., this=0x1bb2b20)
    at /opt/external/boost/boost/asio/detail/task_io_service_operation.hpp:38
#12 boost::asio::detail::task_io_service::do_run_one (this=this@entry=0x75b01248, lock=..., this_thread=..., ec=...)
    at /opt/external/boost/boost/asio/detail/impl/task_io_service.ipp:372
#13 0x000b9958 in boost::asio::detail::task_io_service::run (this=0x75b01248, ec=...)
    at /opt/external/boost/boost/asio/detail/impl/task_io_service.ipp:149
#14 0x000bb5ec in boost::asio::io_service::run (this=this@entry=0x75b00dc4) at /opt/external/boost/boost/asio/impl/io_service.ipp:59
#15 0x000bd15c in SocketServerAdapter::worker (this=0x75b00db0) at /opt/nabase/src/os/tSocketServerAdapter.cpp:160
#16 0x000be558 in operator() (p=<optimized out>, this=<optimized out>) at /opt/external/boost/boost/bind/mem_fn_template.hpp:49
#17 operator()<bool, boost::_mfi::mf0<bool, SocketServerAdapter>, boost::_bi::list0> (f=..., this=<optimized out>, a=...)
    at /opt/external/boost/boost/bind/bind.hpp:249
#18 operator() (this=<optimized out>) at /opt/external/boost/boost/bind/bind.hpp:1294
#19 boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<bool, boost::_mfi::mf0<bool, SocketServerAdapter>, boost::_bi::list1<boost::_bi::value<SocketServerAdapter*> > >, bool>::invoke (function_obj_ptr=...)
    at /opt/external/boost/boost/function/function_template.hpp:138
#20 0x000b2020 in operator() (this=<optimized out>) at /opt/external/boost/boost/function/function_template.hpp:771
#21 BoostThread::worker (this=0x75b02308) at /opt/nabase/src/os/BoostThread.cpp:122
#22 0x000b28a4 in operator() (p=<optimized out>, this=<optimized out>) at /opt/external/boost/boost/bind/mem_fn_template.hpp:49
#23 operator()<boost::_mfi::mf0<void, BoostThread>, boost::_bi::list0> (f=..., this=<optimized out>, a=...)
    at /opt/external/boost/boost/bind/bind.hpp:259
#24 operator() (this=<optimized out>) at /opt/external/boost/boost/bind/bind.hpp:1294
#25 boost::detail::thread_data<boost::_bi::bind_t<void, boost::_mfi::mf0<void, BoostThread>, boost::_bi::list1<boost::_bi::value<BoostThread*> > > >::run (this=<optimized out>) at /opt/external/boost/boost/thread/detail/thread.hpp:116
#26 0x0011a494 in boost::(anonymous namespace)::thread_proxy (param=0x75b02888) at /opt/external/boost/src/thread/pthread/thread.cpp:171
#27 0x76f0cdec in start_thread () from /lib/tls/v7l/neon/vfp/libpthread.so.0
#28 0x76d1b448 in ?? () from /lib/tls/v7l/neon/vfp/libc.so.6
#29 0x76d1b448 in ?? () from /lib/tls/v7l/neon/vfp/libc.so.6
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
(gdb) f 0    
#0  0x0001a428 in release (this=0x75b00ec0) at /opt/external/boost/boost/smart_ptr/detail/sp_counted_base_spin.hpp:103
103	in /opt/external/boost/boost/smart_ptr/detail/sp_counted_base_spin.hpp
````

当前core dump所保存下来的寄存器信息：

```shell
(gdb) info registers
r0             0x75b00ec0	1974472384
r1             0x17fa3c	1571388
r2             0x0	0
r3             0x0	0
r4             0x75b00ec0	1974472384
r5             0x17fa28	1571368
r6             0x758feca8	1972366504
r7             0x0	0
r8             0x5	5
r9             0x758fed58	1972366680
r10            0x758fed30	1972366640
r11            0x75b012c8	1974473416
r12            0x17f248	1569352
sp             0x758fec38	0x758fec38
lr             0x1a404	107524
pc             0x1a428	0x1a428 <boost::detail::shared_count::~shared_count()+96>
cpsr           0x60050010	1610940432
````

Dump时候，对应汇编代码

```shell
(gdb) disassemble
Dump of assembler code for function boost::detail::shared_count::~shared_count():
   0x0001a3c8 <+0>:	push	{r4, r5, r6, r7, r8, lr}
   0x0001a3cc <+4>:	ldr	r4, [r0]
   0x0001a3d0 <+8>:	ldr	r5, [pc, #160]	; 0x1a478 <boost::detail::shared_count::~shared_count()+176>
   0x0001a3d4 <+12>:	cmp	r4, #0
   0x0001a3d8 <+16>:	add	r5, pc, r5
   0x0001a3dc <+20>:	mov	r6, r0
   0x0001a3e0 <+24>:	beq	0x1a470 <boost::detail::shared_count::~shared_count()+168>
   0x0001a3e4 <+28>:	add	r0, r4, #4
   0x0001a3e8 <+32>:	mov	r1, #41	; 0x29
   0x0001a3ec <+36>:	bl	0x13d24
   0x0001a3f0 <+40>:	ldr	r3, [pc, #132]	; 0x1a47c <boost::detail::shared_count::~shared_count()+180>
   0x0001a3f4 <+44>:	mov	r8, r1
   0x0001a3f8 <+48>:	ldr	r5, [r5, r3]
   0x0001a3fc <+52>:	add	r0, r5, r1, lsl #2
   0x0001a400 <+56>:	bl	0x1a370 <boost::detail::spinlock::lock()>
   0x0001a404 <+60>:	ldr	r3, [r4, #4]
   0x0001a408 <+64>:	sub	r2, r3, #1
   0x0001a40c <+68>:	str	r2, [r4, #4]
   0x0001a410 <+72>:	mov	r7, #0
   0x0001a414 <+76>:	str	r7, [r5, r8, lsl #2]
   0x0001a418 <+80>:	cmp	r3, #1
   0x0001a41c <+84>:	bne	0x1a470 <boost::detail::shared_count::~shared_count()+168>
   0x0001a420 <+88>:	ldr	r3, [r4]
   0x0001a424 <+92>:	mov	r0, r4
=> 0x0001a428 <+96>:	ldr	r3, [r3, #8]
   0x0001a42c <+100>:	blx	r3
   0x0001a430 <+104>:	add	r0, r4, #8
   0x0001a434 <+108>:	mov	r1, #41	; 0x29
   0x0001a438 <+112>:	bl	0x13d24
   0x0001a43c <+116>:	add	r0, r5, r1, lsl #2
   0x0001a440 <+120>:	mov	r8, r1
   0x0001a444 <+124>:	bl	0x1a370 <boost::detail::spinlock::lock()>
   0x0001a448 <+128>:	ldr	r3, [r4, #8]
   0x0001a44c <+132>:	sub	r2, r3, #1
   0x0001a450 <+136>:	str	r2, [r4, #8]
   0x0001a454 <+140>:	str	r7, [r5, r8, lsl #2]
   0x0001a458 <+144>:	cmp	r3, #1
   0x0001a45c <+148>:	bne	0x1a470 <boost::detail::shared_count::~shared_count()+168>
   0x0001a460 <+152>:	ldr	r3, [r4]
   0x0001a464 <+156>:	mov	r0, r4
   0x0001a468 <+160>:	ldr	r3, [r3, #12]
   0x0001a46c <+164>:	blx	r3
   0x0001a470 <+168>:	mov	r0, r6
   0x0001a474 <+172>:	pop	{r4, r5, r6, r7, r8, pc}
   0x0001a478 <+176>:	andseq	r4, r6, r8, lsl lr
   0x0001a47c <+180>:			; <UNDEFINED> instruction: 0xffffea94
End of assembler dump.
(gdb) x/32x 0x1974472384
0x74472384:	0x00000000	0x00000000	0x00000000	0x00000000
0x74472394:	0x00000000	0x00000000	0x00000000	0x00000000
0x744723a4:	0x00000000	0x00000000	0x00000000	0x00000000
0x744723b4:	0x00000000	0x00000000	0x00000000	0x00000000
0x744723c4:	0x00000000	0x00000000	0x00000000	0x00000000
0x744723d4:	0x00000000	0x00000000	0x00000000	0x00000000
0x744723e4:	0x00000000	0x00000000	0x00000000	0x00000000
0x744723f4:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) disas 0x13d24, 0x13d88
Dump of assembler code from 0x13d24 to 0x13d88:
   0x00013d24:	add	r12, pc, #1048576	; 0x100000
   0x00013d28:	add	r12, r12, #438272	; 0x6b000
   0x00013d2c:	ldr	pc, [r12, #1308]!	; 0x51c
   0x00013d30:	add	r12, pc, #1048576	; 0x100000
   0x00013d34:	add	r12, r12, #438272	; 0x6b000
   0x00013d38:	ldr	pc, [r12, #1300]!	; 0x514
   0x00013d3c:	add	r12, pc, #1048576	; 0x100000
   0x00013d40:	add	r12, r12, #438272	; 0x6b000
   0x00013d44:	ldr	pc, [r12, #1292]!	; 0x50c
   0x00013d48:	add	r12, pc, #1048576	; 0x100000
   0x00013d4c:	add	r12, r12, #438272	; 0x6b000
   0x00013d50:	ldr	pc, [r12, #1284]!	; 0x504
   0x00013d54:	add	r12, pc, #1048576	; 0x100000
   0x00013d58:	add	r12, r12, #438272	; 0x6b000
   0x00013d5c:	ldr	pc, [r12, #1276]!	; 0x4fc
   0x00013d60:	add	r12, pc, #1048576	; 0x100000
   0x00013d64:	add	r12, r12, #438272	; 0x6b000
   0x00013d68:	ldr	pc, [r12, #1268]!	; 0x4f4
   0x00013d6c:	add	r12, pc, #1048576	; 0x100000
   0x00013d70:	add	r12, r12, #438272	; 0x6b000
   0x00013d74:	ldr	pc, [r12, #1260]!	; 0x4ec
   0x00013d78:	add	r12, pc, #1048576	; 0x100000
   0x00013d7c:	add	r12, r12, #438272	; 0x6b000
   0x00013d80:	ldr	pc, [r12, #1252]!	; 0x4e4
   0x00013d84:	add	r12, pc, #1048576	; 0x100000
(gdb) disas 0x1a370, 0x1a400
Dump of assembler code from 0x1a370 to 0x1a400:
   0x0001a370 <boost::detail::spinlock::lock()+0>:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   0x0001a374 <boost::detail::spinlock::lock()+4>:	mov	r6, r0
   0x0001a378 <boost::detail::spinlock::lock()+8>:	mov	r4, #0
   0x0001a37c <boost::detail::spinlock::lock()+12>:	mov	r5, #1
   0x0001a380 <boost::detail::spinlock::lock()+16>:	mov	r7, #1000	; 0x3e8
   0x0001a384 <boost::detail::spinlock::lock()+20>:	b	0x1a3b8 <boost::detail::spinlock::lock()+72>
   0x0001a388 <boost::detail::spinlock::lock()+24>:	cmp	r4, #3
   0x0001a38c <boost::detail::spinlock::lock()+28>:	bls	0x1a3b4 <boost::detail::spinlock::lock()+68>
   0x0001a390 <boost::detail::spinlock::lock()+32>:	cmp	r4, #31
   0x0001a394 <boost::detail::spinlock::lock()+36>:	bls	0x1a3a0 <boost::detail::spinlock::lock()+48>
   0x0001a398 <boost::detail::spinlock::lock()+40>:	ands	r1, r4, #1
   0x0001a39c <boost::detail::spinlock::lock()+44>:	beq	0x1a3a8 <boost::detail::spinlock::lock()+56>
   0x0001a3a0 <boost::detail::spinlock::lock()+48>:	bl	0x13d0c
   0x0001a3a4 <boost::detail::spinlock::lock()+52>:	b	0x1a3b4 <boost::detail::spinlock::lock()+68>
   0x0001a3a8 <boost::detail::spinlock::lock()+56>:	mov	r0, sp
   0x0001a3ac <boost::detail::spinlock::lock()+60>:	stm	sp, {r1, r7}
   0x0001a3b0 <boost::detail::spinlock::lock()+64>:	bl	0x13d18
   0x0001a3b4 <boost::detail::spinlock::lock()+68>:	add	r4, r4, #1
   0x0001a3b8 <boost::detail::spinlock::lock()+72>:	swp	r3, r5, [r6]
   0x0001a3bc <boost::detail::spinlock::lock()+76>:	cmp	r3, #0
   0x0001a3c0 <boost::detail::spinlock::lock()+80>:	bne	0x1a388 <boost::detail::spinlock::lock()+24>
   0x0001a3c4 <boost::detail::spinlock::lock()+84>:	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   0x0001a3c8 <boost::detail::shared_count::~shared_count()+0>:	push	{r4, r5, r6, r7, r8, lr}
````

经上面分析发现pc值为0x0001a3b8代码执行的是swap r3, r5,  [r6]功能,可在嵌入式汇编函数__asm__ __volatile__中发现代码。
查看0x0001a3b8地址里对应的代码位置。

```bash
root@0b37e82df797:/Hello-install-make-relwithdebinfo_nostrip# addr2line -e bin/sens 0x0001a3b4 -f
_ZN5boost6detail8spinlock4lockEv
/opt/external/boost/boost/smart_ptr/detail/spinlock_gcc_arm.hpp:75 (discriminator 2)
root@0b37e82df797:/Hello-install-make-relwithdebinfo_nostrip# addr2line -e bin/sens 0x0001a3b8 -f
_ZN5boost6detail8spinlock8try_lockEv
/opt/external/boost/boost/smart_ptr/detail/spinlock_gcc_arm.hpp:66 (discriminator 1)
```

经过以上的分析，发现在最终执行的是boost::detail::spinlock里的try_lock()成员函数。spinlock_gcc_arm.hpp文件中。

```c++
#ifdef BOOST_SP_ARM_HAS_LDREX

        __asm__ __volatile__(
            "ldrex %0, [%2]; \n"
            "cmp %0, %1; \n"
            "strexne %0, %1, [%2]; \n"
            BOOST_SP_ARM_BARRIER :
            "=&r"( r ): // outputs
            "r"( 1 ), "r"( &v_ ): // inputs
            "memory", "cc" );

#else

        __asm__ __volatile__(
            "swp %0, %1, [%2];\n"
            BOOST_SP_ARM_BARRIER :
            "=&r"( r ): // outputs
            "r"( 1 ), "r"( &v_ ): // inputs
            "memory", "cc" );

#endif
```

```c++
#if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_7S__)

# define BOOST_SP_ARM_BARRIER "dmb"
# define BOOST_SP_ARM_HAS_LDREX

#elif defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__)

# define BOOST_SP_ARM_BARRIER "mcr p15, 0, r0, c7, c10, 5"
# define BOOST_SP_ARM_HAS_LDREX

#else

# define BOOST_SP_ARM_BARRIER ""

#endif
```


#### 分析：
上面代码由于未定义ARM的架构，宏BOOST_SP_ARM_HAS_LDREX为定义，该宏定义为空# define BOOST_SP_ARM_BARRIER ""。__asm__ __volatile__函数中使用了swp指令。在交叉编译nena里的boost默认是没有指定处理器架构，如” (__ARM_ARCH_7__)”,” (__ARM_ARCH_6__)” ……等。
分析结果：
设备是使用的ARM架构为ARMv7-A，而我们却使用了默认编译ARMV6前架构指令，导致原子操作会出问题，可参考相关文章。
ARM官网关于Coretex-A9信息：

http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.set.arm7/index.html

```
Cortex-A9 series processors Cortex logo
ARM documentation set for the ARM Cortex-A9 processors, including the ARM Cortex-A9 MPCore and ARM Cortex-A9 single core processors.
The ARM Cortex-A9 processor is a very high-performance, low-power, ARM macrocell with an L1 cache subsystem that provides full virtual memory capabilities. The Cortex-A9 processor implements the ARMv7-A architecture profile and can execute 32-bit ARM instructions, 16-bit and 32-bit Thumb instructions, and 8-bit Java bytecodes in Jazelle state.
```

相关说明：
早期的ARM指令集（V6前）提供SWP指令实现同步的功能，ARMV7l。应该使用LDREX和STREX。ARM内核的Exclusive Monitor的机制实现。

```
ARM Synchronization Primitives Development Article：
Appendix A. SWP and SWPB
This appendix describes the legacy SWP and SWPB instructions, used for synchronization on processors based on ARMv5 architecture and earlier. It contains the following section:
    Legacy synchronization instructions
Note
The SWP and SWPB instructions are deprecated from ARM architecture version 6 onwards. This appendix is included for historical completeness only. Use Load-Exclusive and Store-Exclusive for all new software development for processors implementing ARMv6 or later.
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dht0008a/ch01s02s01.html

LDREX and STREX
The LDREX and STREX instructions split the operation of atomically updating memory into two separate steps. Together, they provide atomic updates in conjunction with exclusive monitors that track exclusive memory accesses, see Exclusive monitors. Load-Exclusive and Store-Exclusive must only access memory regions marked as Normal.
```

http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dht0008a/ch01s02s01.html

#### 解决方法：
编译应用时候指定arm指令集、架构、浮点单元等信息参数如下：
```
-march=armv7-a -mthumb-interwork -mfloat-abi=soft -mfpu=neon -mtune=cortex-a9
```
cmake编译:
```
CMAKE_CXX_FLAGS, CMAKE_C_FLAGS
```
gcc编译：
```
CFLAGS，CXXFLAGS
```



